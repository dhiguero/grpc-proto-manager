package repo

import (
	"fmt"
	"os/exec"
	"strings"

	"github.com/rs/zerolog/log"
)

const NoTagsFoundErrorMsg = "No names found, cannot describe anything"

// GitHubCmdProvider structure with the implementation to manage a GitHub system.
// This implementation relies on leveraging the existing git command on the system. In the
// future another provider making use of the API or golang SDK should be added :)
type GitHubCmdProvider struct {
}

// NewGitHubCmdProvider creates a new provider connecting to GitHub.
func NewGitHubCmdProvider() (Provider, error) {
	log.Debug().Msg("Using GitHubCmdProvider")
	return &GitHubCmdProvider{}, nil
}

// GetRepoURL builds the URL require for clone and commit operations.
func (gh *GitHubCmdProvider) GetRepoURL(organization string, repoName string) string {
	return fmt.Sprintf("git@github.com:%s/%s.git", organization, repoName)
}

// Clone a given repository to a path
// git clone git@github.com:whatever folder-name
func (gh *GitHubCmdProvider) Clone(repoURL string, outputPath string) error {
	log.Debug().Str("repoURL", repoURL).Str("outputPath", outputPath).Msg("cloning repository")
	// TODO Check output path exists.
	cmdArgs := []string{"clone", repoURL, outputPath}

	cmd := exec.Command("git", cmdArgs...)
	stdoutStderr, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("unable to clone repo %s due to %w", repoURL, err)
	}

	log.Debug().Str("output", string(stdoutStderr)).Msg("repo successfully cloned")
	return nil
}

// GetLastVersion obtains the latest version of the repo.
// git describe --abbrev=0 --tags
func (gh *GitHubCmdProvider) GetLastVersion(repoPath string) (*Version, error) {
	log.Debug().Str("repoPath", repoPath).Msg("obtaining latest tag")
	// TODO Check output path exists.
	cmdArgs := []string{"describe", "--abbrev=0", "--tags"}

	cmd := exec.Command("git", cmdArgs...)
	cmd.Dir = repoPath
	stdoutStderr, err := cmd.CombinedOutput()
	if err != nil {
		if strings.Contains(string(stdoutStderr), NoTagsFoundErrorMsg) {
			return EmptyVersion(), nil
		}
		return nil, fmt.Errorf("unable to obtain latest tag from repo %s due to %w, %s", repoPath, err, string(stdoutStderr))
	}

	log.Debug().Str("output", string(stdoutStderr)).Msg("repo successfully cloned")
	return FromTag(string(stdoutStderr))
}

// Publish the changes and create a new version tag.
func (gh *GitHubCmdProvider) Publish(repoPath string, newVersion *Version) error {
	log.Debug().Str("repoPath", repoPath).Str("version", newVersion.String()).Msg("publishing version")

	// TODO improve commit message
	// Add all new files
	addCmdArgs := []string{"add", "-A"}
	_, err := gh.execCmd("git", addCmdArgs, repoPath)
	if err != nil {
		return err
	}
	// Commit changes
	commitCmdArgs := []string{"commit", "-a", "-m", fmt.Sprintf("gpm automatic publish")}
	_, err = gh.execCmd("git", commitCmdArgs, repoPath)
	if err != nil {
		return err
	}

	// Push changes
	pushCmdArgs := []string{"push"}
	_, err = gh.execCmd("git", pushCmdArgs, repoPath)
	if err != nil {
		return err
	}
	// Create new tag
	// tag -a v1.4 -m "my version 1.4"
	tagCmdArgs := []string{"tag", "-a", newVersion.String(), "-m", fmt.Sprintf("new version %s generated by GPM", newVersion.String())}
	_, err = gh.execCmd("git", tagCmdArgs, repoPath)
	if err != nil {
		return err
	}
	// Push the tags
	// git push origin --tags
	pushTagCmdArgs := []string{"push", "origin", "--tags"}
	_, err = gh.execCmd("git", pushTagCmdArgs, repoPath)
	if err != nil {
		return err
	}
	return nil
}

// execCmd executes a given command and returns the output if successful.
func (gh *GitHubCmdProvider) execCmd(cmd string, args []string, workingDir string) (string, error) {
	toExecute := exec.Command("git", args...)
	toExecute.Dir = workingDir
	stdoutStderr, err := toExecute.CombinedOutput()
	if err != nil {
		return string(stdoutStderr), fmt.Errorf("unable to execute command %s due to %w, %s", cmd, err, string(stdoutStderr))
	}
	log.Debug().Str("output", string(stdoutStderr)).Msg("execution finished")
	return string(stdoutStderr), nil
}
